/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package de.gipmbh.gradle.plugins.release

import com.github.zafarkhaja.semver.Version
import org.gradle.api.Plugin
import org.gradle.api.Project
import pl.allegro.tech.build.axion.release.domain.*
import pl.allegro.tech.build.axion.release.domain.properties.VersionProperties.Incrementer


class GipReleasePlugin : Plugin<Project> {
    override fun apply(project: Project) {

        project.plugins.apply("pl.allegro.tech.build.axion-release")

        val versionConfigExtension =
            project.extensions.create("releaseBranch", VersionConfigExtension::class.java)

        versionConfigExtension.leastVersion.convention("1.0.0")
        // versionConfigExtension.incrementer.convention("incrementPatch")


        versionConfigExtension.directory.convention(
            project.objects.directoryProperty().convention(project.layout.projectDirectory.dir("./"))
        )

        project.extensions.configure("scmVersion") { versionConfig: VersionConfig ->
            versionConfig.repository { repositoryConfig: RepositoryConfig ->
                repositoryConfig.directory.set(versionConfigExtension.directory)
            }
            versionConfig.tag { tagNameSerializationConfig: TagNameSerializationConfig ->
                tagNameSerializationConfig.prefix.set(versionConfigExtension.tagPrefix)
                tagNameSerializationConfig.initialVersion { _, _ -> "1.0.0" }
            }
            versionConfig.ignoreUncommittedChanges.set(versionConfigExtension.ignoreUncommittedChanges)
            versionConfig.useHighestVersion.set(versionConfigExtension.useHighestVersion)

            versionConfig.versionCreator("versionWithBranch")

            if (project.hasProperty("ignoreUncommitted")) {
                versionConfig.checks { versionConfig.checks.uncommittedChanges.set(true) }
            }

//            versionConfigExtension.incrementer.map { incrementerValue ->
//                incrementerValue.toInt()
//            }

            versionConfig.versionIncrementer.set(
                versionConfigExtension.incrementer.map { incrementer ->
                    leastVersionIncrementer(
                        incrementer,
                        versionConfigExtension.leastVersion.get()
                    )
                }.orElse(
                    versionConfigExtension.leastVersion.map { leastVersion ->
                        leastVersionIncrementer(
                            "incrementMinor",
                            leastVersion
                        )
                    }
                )
            )

            versionConfig.branchVersionIncrementer.putAll(versionConfigExtension.incrementer.map {
                emptyMap<String, Any>()
            }.orElse(
                versionConfigExtension.leastVersion.map { leastVersion ->
                    mapOf<String, Any>(
                        "(release/|support/).*" to leastVersionIncrementer(
                            "incrementPatch",
                            leastVersion
                        )
                    )
                }
            ))
        }
    }

    private fun leastVersionIncrementer(
        incrementerName: String, leastVersion: String
    ): Incrementer {

        return Incrementer { context: VersionIncrementerContext ->
            val incrementer: Incrementer =
                PredefinedVersionIncrementer.versionIncrementerFor(incrementerName)
            val parsedLeastVersion: Version = Version.parse(leastVersion)
            if (parsedLeastVersion > context.currentVersion) parsedLeastVersion else incrementer.apply(context)
        }
    }
}

/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package de.gipmbh.gradle.plugins.release

import com.github.zafarkhaja.semver.Version
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.provider.Property
import pl.allegro.tech.build.axion.release.domain.*
import pl.allegro.tech.build.axion.release.domain.properties.VersionProperties


class GipReleasePlugin : Plugin<Project> {
    override fun apply(project: Project) {

        project.plugins.apply("pl.allegro.tech.build.axion-release")

        val versionConfigExtension: VersionConfigExtension =
            project.extensions.create("releaseBranch", VersionConfigExtension::class.java)

        versionConfigExtension.leastVersion.convention("1.0.0")
//        versionConfigExtension.incrementer.convention("incrementPatch")


        versionConfigExtension.directory.convention(
            project.objects.directoryProperty().convention(project.layout.projectDirectory.dir("./"))
        )

        project.extensions.configure("scmVersion") { versionConfig: VersionConfig ->
            versionConfig.repository { repositoryConfig: RepositoryConfig ->
                repositoryConfig.directory.set(versionConfigExtension.directory)
            }
            versionConfig.tag { tagNameSerializationConfig: TagNameSerializationConfig ->
                tagNameSerializationConfig.prefix.set(versionConfigExtension.tagPrefix)
                tagNameSerializationConfig.initialVersion { _, _ -> "1.0.0" }
            }
            versionConfig.ignoreUncommittedChanges.set(versionConfigExtension.ignoreUncommittedChanges)
            versionConfig.useHighestVersion.set(versionConfigExtension.useHighestVersion)

            versionConfig.versionCreator("versionWithBranch")

            if (project.hasProperty("ignoreUncommitted")) {
                versionConfig.checks { versionConfig.checks.uncommittedChanges.set(true) }
            }


            if (versionConfigExtension.incrementer.isPresent) {
                versionConfig.versionIncrementer(
                    leastVersionIncrementer(
                        versionConfigExtension.incrementer,
                        versionConfigExtension.leastVersion
                    )
                )
            } else {
                versionConfig.versionIncrementer(
                    leastVersionIncrementer(
                        project.objects.property(String::class.java).convention("incrementMinor"),
                        versionConfigExtension.leastVersion
                    )
                )
                versionConfig.branchVersionIncrementer(
                    mapOf(
                        "(release/|support/).*" to leastVersionIncrementer(
                            project.objects.property(String::class.java).convention("incrementPatch"),
                            versionConfigExtension.leastVersion
                        )
                    )
                )
            }
        }
    }

    private fun leastVersionIncrementer(
        incrementerName: Property<String>, leastVersion: Property<String>
    ): (VersionIncrementerContext) -> Version {
        val incrementer: VersionProperties.Incrementer =
            PredefinedVersionIncrementer.versionIncrementerFor(incrementerName.get())

        return { context: VersionIncrementerContext ->
            val parsedLeastVersion: Version = Version.parse(leastVersion.get())
            if (parsedLeastVersion > context.currentVersion) parsedLeastVersion else incrementer.apply(context)
        }
    }
}
